BigQuery:
	1) Можно создавать функции изнутри
	2) Сожно делать запросы к экстерна сторам(федерал риквест)
	3) Project -> Dataset -> Tables
	4) Все инкриптится
	5) Вью - еще один способы защиты данных
	6) Используется для анализа, ML и репортинга
	7) Рассчитан на анализ огромного количества данных
	8) Платить можно как и за запросы, так и за объем данных
	9) Денормализованная таблица, порождает большую производительность(схема)
	10) Присутствует поддержка такого типа полей, как Nested and Repeated
	11) Тип данных Struct (event.time, event.status etc.) (Как преджоин таблиц)
	12) Тип данных Array (event.time, event.status etc.) (Как набор данных)
	13) Коломно-ориентированный, значит не подгружает весь датасет при поиске
	14) Partitions разбивает колонну на части, что делать поиск проще
	15) Из-за разделение колноки, увеличивается количество метаданых
	16) BigQuery автоматически сортирует колонки помеченные кластерными
	17) Так же имеет смысл порядок в котором находятся кластеризуемые колонки
	18) Помогает решить проблемы связанные с качеством данных через SQL.
	19) Батч данные предпочтительнее чем стрим
	20) Поддерживает GIS функции (геолокация и тд)
	21) Прославляется денормализация
	22) GeoViz отображает точки на карте 
	23) Поддерживает WITH, который сохраняет в себе всегда исполняемы SELECT
	24) С помощью LAG() мы можем вернуться к предыдущему значению
	25) Кеширование применяется при схожести запросов
	26) Кеширование на происходит при неопределенных запросах
	27) WITH and VIEW не кешируются
	28) BI мб использован для кеширования таблиц
	29) Нужно избегать джоинов
	30) Вместо селфи Джон использовать агрегацию
	31) Минимизируйте сортировку так как она исполнятся на 1 воркере
	32) В джоинах большую таблицу слева
	33) Cортировку производить в последнюю очередь
	34) Фильтровать раньше и чаще
	35) BQ ML позволяет писать ML задачи на SQL-like синтексе 
	36) log_reg model служит для выбора категории (линейный) (прилет самолета)
	37) ML.EVALUATE(*model*) оценивает модель по показателям
	38) din_classifier более сложны классификатор (не линейный) (износ машины)
	39) lineral_reg используется для линейного предсказания (линейный) (t/f)
	40) dnn_regresor -||- (не линейный)
	41) Можно загружать модели из Tensorflow
	42) matrix_factorization модель для рекомендаций 

BigTable:
	1) Более быстрая чем BigQuery
	2) NoSQL синтакс
	3) Не подходит для больших файлов
	4) Создан для решения спецефических задач на скорость
	5) Подходят не для структурированных дат
	6) Хранятся данные в файловой системе под названием Colossus
	7) Строится на файлах, которые хранят таблицы и метаинформацию
	8) Может манипулировать всем в своей системе
	9) Разворачивается на многих машинах 
	10) Может существовать только один индекс и данные сортируются по индексу
	11) Почти нет стандартных операторов, из чего следует, название NoSQL
	12) При проектировки нужно выбирать такой row key, который чаще вызывается
	13) Данные мб организованы по фамилиям 
	14) Отсутсвие значение не занимает никакой памяти, поэтому делай большую таблицу
	15) Позволяет работать с стриминговыми данными

Storage:
	1) DataLakes
	2) Хранит в себе все виды данных (объекты)
	3) Backet -> Object
	4) Все так же отлично инкриптится, как объекты, так и баккеты

Dataproc:
	1) Под капотом машина с Hadoop c Spark и многими другими приблудами
	2) Хранить данные нельзя, так как постоянно меняются кластеры 
	3) Можно создавать и удалять кластеры
	4) Легко интегрируемая с хранилищами
	5) Легко создавать кластеры по нуждам
	6) Работы по дефолту не перезапускаемые
	7) Нельзя их задавать через интерфейс
	8) Самой главной выгодой является разделение выполнения и хранения
	9) Хранить в HDFS стоит только когда есть много метадаты и переименовываются папки
	10) YAML содержит шаблон создания hadoop процесса
	11) StackDriver используется для мониторинга процессов Hadoop 

DataFusion:
	1) Продукт для графического построения потоков
	2) Юзается для трансформирования, ремува дубликатов, монитора и тд
	3) Под капотом работа достигается с помощью Dataproc
	4) Если есть свой Dataproc, DataFusion можно запустить по верх него
	5) Содержит кучу сервисов, управляющих потоком данных
	6) Wrangler - можем сконвертировать данные в поток данных
	7) Data Pipeline - для строительства сложных воркфлоу
	8) Rules Engin - для мониторинг и планирования ворк флоу
	9) Metadata Aggregator - Создание метадаты и дата  словарей
	10) Пайплайны билдятся с помощью DAG
	11) ИСПОЛЬЗУЕТСЯ ДЛЯ ОБРАБОТКИ БАТЧ ПОТОКОВ
	12) Можно просматривать ход филда (откуда/куда)

DataComposer:
	1) Строит пайплайны с любым сервисом gcp
	2) Управляется с помощью Apache airflow
	3) Идея в том, чтобы соединять абсолютно разные задачки
	4) Есть куча встроенных операторов связанных с GCP

Dataflow:
	1) Полностью управляемый процесс на основе Apache Beam для построения pipeline
	2) Пайплайны могут быть бач и стрим, причем код одинаковый
	3) Служит для обработки дата процесов
	4) По структуре схож с Airflow
	5) Apache Beam решает то как будет выполнятся та или иная задача
	6) Dataflow решает то как будут связаны эти задачи
	7) Постоянно происходит оптимизация 
	8) Окна группируют стриминговые элементы в группы по признаку (i.e. Времени)
	9) Watermark - техника для рассвета времени между приходом элемента и его времени

DataCatalog:
	1) Знать метаданные данных (от куда, какого качества, сможем ли мы его обработать)
Это может понадобится для дальнейшей обработке данных, при получении странных результатов
Labels(BigQuery) на датасет, таблицу, вью может помочь организовать ресурсы

DataStudio:
	1) Визуализирует данные

Pub/Sub:
	1) Асинхронная шина сообщений
	2) По сути считывает данные с источника и без преобразования посылает подписчику
	3) Принцип работы как у jms
	4) Availabilty, Durability, Scalability
	5) Имеется возможность хранить сообщения до того как их сможешь прочитать (буффер)
	6) Основано на топиках и подписках 
	7) Поддерживает две, push и pull модели
	8) pull - подписчики посылают запрос на получение сообщений, и обратно ack
	9) push - топик сам посылает подписчикам сообщения, и получает обратно ack (HTTP)
	10) Если ack не был получен, сообщение еще раз пересылается 
	11) Sub может получать как синхронно так и асинхронно
	12) Сообщения могут приходить не в порядке
	13) Могут приходить дубликаты
	14) Подписчики получают сообщения только после того как они были подписаны

AI Platform:
	1) Сервис на основе TensorFlow
	2) Позволяет писать пользователям свои алгоритмы для ML

Cloud AutoML:
	1) Сервис для которого нужно лишь данные, писать код не надо
	2) Модели которые не используются, удаляются через время

Pre-trained ML model:
	1) Набор натренированных моделей, которые юзер может использовать для своих нужд
	2) Дает хорошие результаты, только если данные пользователя подходят

CloudAI:
	1) Авторасширяемая, трансформирующая данные на входе и тд
	2) Поддерживает Notebooks

KubeFlow:
	1) Пакует ML задачи для Kubernetes
	2) Служит для строительства BL пайплайнов
	3) Похож на DataComposer
	4) Можно использовать Notebook для дефайна workflow
	5) Пишутся пайплайны с помощью Python SDK
	6) Можно упаковывать в пакеты пайплайны, для дальнейшего реюза 

AI Hub:
	1) Хранлище с готовыми пайплайнами, датасетами и тд

-------------------------------------------------------------------------

Требования качества данных: Validity(Подходит к требованиям бизнеса),
Accuracity(Точность данных),
Completeness(Не должно быть пропущенных значений),
Consistency(За уникальность данных),
Uniformity(Однообразность данных)
Эти требования независимы 

EL -> Data -> BigQuery
ELT -> Data -> BigQuery -> BigQuery
ETL -> Data -> Dataflow, Dataproc -> BigQuery

DataBeam компоненты:
	1) PCollection хранит данные, которые будут обработаны. Неизменяемый
	2) PTransforms действия (код) над коллекцией данных. Содержит I -> T -> O
	3) Pipeline Runners дом пайплайнов (Dataflow, VM, etc) 
	
Machine Learning:
	1) ML строится на стандартных алгоритмах, которые могу быть натрененрованы на разные вещи, основываясь на входных данных 
	2) Model - случай, для которого тренируется алгоритм
	3) Первый шаг в ML дать как можно больше модели, чтобы она натренировалась
	4) Label - корректные ответы для входных данных
	5) AI(физика) -> ML(разделы) -> DL(глубокие подразделы)
	6) Для ML отлично подходит Notebook(Jupiter) для построение пайплайнов
	7) ML отлично интегрируется с другими сервисами GCP





GCP ADVANCED

BigQuery:
 У него идет разделение на project -> dataset -> table. BigQuery берет как деньги за хранение так и за запросы которые мы запускаем на этих данных. Не имеет значение то, сколько будет обрабатываться данных через LIMIT, важно лишь только то, что мы берем все колонки, а это значит что в независимости от LIMIT будут обрабатываться все колонки.
 Добавление слова distinct в случае count( distinct gender ) посчитает нам не все колонки, а только уникальные. NULL значения не считаются при подсчете count у какой-то определенной колонки. Он работает на все колонки сразу.
 WHERE как и обычно сортирует данные по какому-то показателю. При этом не уменьшает количество обрабатываемых данных. IN окружается круглыми скобками. Like statement позволяет поместить колонку под regular expr.
 cast - функция которая позволяет нам кастовать один тип к другому.
 extract - функция позволяющая доставать часы/минуты/секнды и другие составные из даты.
 С timestamp можно манипулировать так же как с int, > or < and etc.
 GROUP BY, HAVING имеет то же поведение что и всегда.
 JOIN такой же как и везде, при этом по дефолту INNER подразумевает INNER JOIN.
 Математические функции соответствуют стандарту SQL, возвращают null or NaN если приходя соответсвующие параметры.
 rand() - функция которая выводит случайное число
 Разница между datetime and timestamp следующая, datetime мы не можем кешировать и по нему индексировать. Так же для работы с ними есть свои специальные функции. Ex.: timestamp_diff and datetime_diff. 
 CASE
    WHEN *condition* THEN ... - обычный CASE statement в рамках Big Query.
    ...
    ELSE ...
 END AS ...
 ....
 The records can be in Avro, CSV, JSON (newline delimited only), ORC, or Parquet format. Export data from Datastore or Firestore and load the exported data into BigQuery. Load data from other Google services, such as Google Ad Manager and Google Ads

 Anti-patterns:
  Self-joins: Typically, self-joins are used to compute row-dependent relationships. The result of using a self-join is that it potentially doubles the number of output rows. This increase in output data can cause poor performance. Instead of using a self-join, use a window (analytic) function to reduce the number of additional bytes that are generated by the query.
  Data Skew: Partition skew, sometimes called data skew, is when data is partitioned into very unequally sized partitions. This creates an imbalance in the amount of data sent between slots. You can't share partitions between slots, so if one partition is especially large, it can slow down, or even crash the slot that processes the oversized. Best practice: If your query processes keys that are heavily skewed to a few values, filter your data as early as possible.
  Unbalanced joins: Data skew can also appear when you use JOIN clauses. Because BigQuery shuffles data on each side of the join, all data with the same join key goes to the same shard. This shuffling can overload the slot.
  Cross Join: Best practice: Avoid joins that generate more outputs than inputs. When a CROSS JOIN is required, pre-aggregate your data.
  DML statements that update or insert single rows: Best practice: Avoid point-specific DML statements (updating or inserting 1 row at a time). Batch your updates and inserts.
 
 Best practice: 
  Avoid SELECT *: 
  Sample data using preview options:
  Price your queries before running them:
  Using the query validator:
  Using the pricing calculator:
  Limit query costs by restricting the number of bytes billed:
  LIMIT doesn’t affect cost:
  View costs using a dashboard and query your audit logs:
  Partition data by date:
  Materialize query results in stages:
  Consider the cost of large result sets: Best practice: If you are writing large query results to a destination table, use the default table expiration time to remove the data when it's no longer needed.
  Use streaming inserts with caution: There is no charge for loading data into BigQuery. There is a charge, however, for streaming data into BigQuery.
 Так же приходиться платить за хранение данных.

DataProc:
 Главная цель - использовать манежить Hadoop кластер за тебя, предоставляя удобный UI. Быстро поднимается и более дешевый путь, чем делать все самому. Он интегрирован с другими GCP сервисами.
 Платить за сервис приходиться по следующей формуле: $0.010 * # of vCPUs * hourly duration. Но при этом, у нас происходит взятие денег посекундно. И по мимо этой цены, прийдется еще платить и за Compute Engine Instance, и за Engine Persistence Disks.
 AccessControl:
  Для юзеров доступны только Viewer or Editor mode. Viewer может только смотреть на кластер, Джобы и операции, но не может создать/удалять и джобы и кластер. Editor может делать и то и другое. Такие разрешения применимы на уровне проекта. Назначение ролей можно произвести в IAM, там уже назначения либо на уровне Dataproc, либо на уровне Project menu. Worker - это роль, которая отвечает за запуск и мониторинг тасок.
  ServiceAccount - это то что другие сервисы используют для аутентификации перед другими сервисами. К примеру, Compute Engine использует сервис аккаунт для того, чтобы аутентифицироваться в Cloud Storage, и если он смог все таки подключиться, то это значит, что этому Service Account разрешено взаимодействовать с Cloud Storage. При создании кластера указывается определенный Service Account.
 PreemptibleNode стоит 1/5 RegularNode, но есть проблема с тем, что Google Cloud может удалить эти компьютеры, если ему будет это нужно.
 Возможно спокойно удалять, добавлять ноды.
 Вообще использование считается правильным, когда мы поднимаем кластер для какой-то джобы, и как она отработала, вырубаем кластер.
 Пишет логи в StackDriver.
 Есть Connectors to BigQuery, Cloud Storage, Cloud Bigtable.
 Чере cli передаются проперти, как --properties 'spark:spark.driver.maxResultSize = 2g, ...' Эти проверти только доступны либо через cli, либо через console.
 Можно ставить Initialization actions, они позволяют запускать скрипт во время старта кластера. Скрипт должен лежать в gs. 
 Worker должны иметь одну и ту же конфигурацию. Для использования PreemptibleNode, должно быть по крайней мере задействовано 3 машины.
 У User могут быть Viewer or Editor roles, а у Service account - Worker role.
 BigDL:
  Библиотека для запуска DeepLearning программ на Spark. 
 Secondary workers:
  1) Processing only — Secondary workers do not store data. 
  2) No secondary - worker-only clusters—Your cluster must have primary workers. 
  3) Machine type — Secondary workers use the machine type of the cluster's primary workers. 
  4) Persistent disk size — As a default, secondary workers are created with the smaller of 100GB or the primary worker boot disk size
 Autoscaling is not recommended for:
  HDFS: Autoscaling is not intended for scaling on-cluster HDFS. 
  YARN Node Labels: Autoscaling does not support YARN Node Labels, nor the property dataproc:am.primary_only due to YARN-9088. YARN incorrectly reports cluster metrics when node labels are used.
  Spark Structured Streaming: Autoscaling does not support Spark Structured Streaming (see Autoscaling and Spark Structured Streaming).
  Idle Clusters: Autoscaling is not recommended for the purpose of scaling a cluster down to minimum size when the cluster is idle.

DataFlow:
 Сервис для стриминговой и батч обработки данных, на основе ApacheBeam.
 Есть два вида данных, Bounded - сформированный набор данных and unbounded - стрим данных, который никогда не будет с компликтован.
 3Vs - Volume, Velocity, Variety.
 Под капотом то же самое что и в спарк, берет данные, разбивает их, выполняет вычисления и затем выдает результат. PCollection == RDD.
 Особенности:
  Входные данные автоматически ребаллансируются.
  Так же есть некий концепт Flexible scheduling, это когда бати джобу ставят в какую-ту временную рамку и затем выполняют с гарантией в промежуток 6 часов.
  Есть уже готовые к использованию AI паттерны.
 All features:
  Streaming Engine - передвигает часть вычислений с worker VMs and into the Dataflow service back end.
  Autoscaling - Autoscaling lets the Dataflow service automatically choose the appropriate number of worker instances required to run your job.
  Dataflow Shuffle - Service-based Dataflow Shuffle moves the shuffle operation, used for grouping and joining data, out of the worker VMs and into the Dataflow service back end for batch pipelines.
  Dataflow SQL - Dataflow SQL lets you use your SQL skills to develop streaming Dataflow pipelines right from the BigQuery web UI.
  Flexible Resource Scheduling (FlexRS)	- Dataflow FlexRS reduces batch processing costs by using advanced scheduling techniques, the Dataflow Shuffle service, and a combination of preemptible virtual machine (VM) instances and regular VMs. 
  Dataflow templates - Dataflow templates allow you to easily share your pipelines with team members and across your organization or take advantage of many Google-provided templates to implement simple but useful data processing tasks.
  Notebooks integration	- Iteratively build pipelines from the ground up with AI Platform Notebooks and deploy with the Dataflow runner.
  Inline monitoring - Dataflow inline monitoring lets you directly access job metrics to help with troubleshooting batch and streaming pipelines.
  Customer-managed encryption keys - You can create a batch or streaming pipeline that is protected with a customer-managed encryption key (CMEK) or access CMEK-protected data in sources and sinks.
  Dataflow VPC Service Controls - Dataflow’s integration with VPC Service Controls provides additional security for your data processing environment by improving your ability to mitigate the risk of data exfiltration.
  Private IPs - Turning off public IPs allows you to better secure your data processing infrastructure. 
 Pricing:
  Dataflow jobs are billed per second, based on the actual use of Dataflow batch or streaming workers. 
 Все начинается с Driver Programm, где мы определяем Pipeline, включающий в себя inputs, transforms and outputs, так же определяет опции, которые передаются пайплайну.
 Pipeline инкапсулирует всю работу приложения от начала до конца. При его создании, мы определяем где и как запускать этот pipeline. 
 Runner - это то, что выполняет pipeline. PCollection - это то, на чем оперирует pipeline. PCollection - выходные и выходные степы для каждого шага в рамках pipeline. 
 Transform - это операции, которые оперируют на PCollection, и в качесте результата возвращает новый PCollection. 
 Source/Sink - откуда/куда читаются данные (это просто куски кода которые определяют сорсы и синки).
 Есть такие же концепты, как Processing and Event time, работают так же как и в Spark.

















