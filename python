Python очевидно не типизированный ЯП, который позволяет нам писать сжатые программы за счет своей не многосложности. Является высокоуровневым ЯП. Проверка типов происходит in runtime instead of compile time, что добавляет свои плюсы в скорости написания и минусы в скорости работы. Большое внимание уделяется Readability. Является interpreted и multi-paradigm (OO and Structure). Является Dynamic Strong язык, это означает что он присваивает тип переменным только во время компиляции и что он не проводит implicit преобразований. 
Можно переопределять операторы.

Плюсы Питона:
 1) Extensible Design - Много функциональности может быть добавлено on top of core Python.
 2) Community Evolved Design - Через PEP.
 3) Emphasizing FUN
 4) Culture

Pip - это пакетный менеджер, которы позволяет нам загружать и удалять пакеты.
PEP[Python Enhancement Proposals] - предложенные нововведения в Python.
PyPI - python package index - репозиторий с которого pip берет python пакеты.

Python 3 не совместим с Python 2. Так что при внедрении новых фич, они не должны были оглядываться на версию 2. 
Главные различия:
 1) Print is a function :: Print is a statement 
 2) When two integers divided, will get float value if required :: When two integers divided, always get only integer value
 3) Storing string as UTF-8 :: Need to specify "u".
 4) Syntax becomes more simpler and easily understandable :: Syntax was quite difficult to python3.
 5) Rules of ordering comparisons has been simplified :: It's more complexed to python3.
 6) Range() introducers for iterations :: Xrange() is used for iterations
 7) The value of variables does't leak :: The value of global variable got changed while using that in for - loop.
 8) Exception argument should be enclosed in parenthesis :: Exception argument can be enclosed in notation.

Выполнять python код можно 3-я способами:
 1) Interpreter - выполнить код который записан в py файл.
 2) REPL.
 3) Natively - когда запускаем python программы не заботясь о версии Python и о нем вообще, производится с помощью: py2exe, pyinstaller and etc.

Стандартные библиотеки у Python насыщенные, позволяют решать real world задачи прямо из коробки.

Types in Python:
 Нет таких как longs and double. Динамическая типизация позволяет ускорить разработку. Но с другой стороны это ведет к большому количеству багов. Так как если будут несопоставимые типы, то программа упадет во время выполнения, а не компиляции как в ЯП со строгой типизацией. 
 Types Hinting - позволяет добавить тип к переменным в python def add(a:int, b:int) -> int : return a + b;
 1) Integers - num = 42. Имеет не ограниченный размер.
 2) Floats - float = 3.14159. Можно создавать по типу 1.655е-35 или inf. 
 3) String - a = "text". Представляет текст в Unicode. Объявление строк с 3-я кавычками позволяет использовать эту строку как комментарий. Объявленные рядом строчки конкатенируются. С ним можно обращаться как с листом. Использование + может вести к деградации, лучше использовать join на пустой строке. Полезной будет функция partition, которая разделяет результат на 3 части по сепаратору: до, сепаратор, после (возвращает tuple).
 4) Boolean - bool = True/False. Их можно конвертировать в int и получить 1/2 соответсвенно. 
 5) None - nn = None. То же что и null в других языках. В if преобразуется в False.
 6) List - students = [...]. Взять элементы можно по индексу students[0]. (Slicing) Для того чтобы взять последний элемент, можно написать students[-1], где индексы считаются в обратном порядке: самый последний = -1, предыдущий = -2 и тд. Для замены элемента в list, нужно всего лишь: students[0] = "smth". Для добавления использовать функцию append() [добавляет в конец]. Для проверки элемента в list, нужно написать "smth" in students. len(student) - возвращает размер листа. Пайтон позволяет нам добавлять в лист сколько угодно значений каких угодно разных типов. Для удаления элементов из списка del students[0]. Slicing - позволяет игнорировать какое-то количество элементов в списке students[1:] - выводит все элементы начиная с первого, или можно использовать в таком виде students[1:-1] - выводит все кроме первого и последнего. List[:] - скопирует лист.
 7) Dictionaries - аналог JSON. Для получения элемента можно действовать таким образом student['name'], если взять ключ которого нет, то выпадет ошибка, чтобы ее избежать, можно использовать student.get('last_name', 'Unknown'). student.keys() - получить все ключи. student.values() - получить все значения. Менять и удалять значения так же как и в list. in and not in works only for keys. Ключи должны быть immutable, а значения mutable.
 9) complex.
 10) bytes and bytearray. - очень похожи на str, где у нас строка представляет набор байтов а не символов Юникода.
 11) tuples - immutable коллекция элементов. В последних версиях скобочки при объявления могут быть опущены. Легко можно unpack. Возможно использование in and not in. При создании листа с помощью [[1,2]]*4 => получается 4 одинаковых списка в 1 списке.
 12) set and frozen set - уникальная коллекция элементов. Каждый элемент в коллекции должен быть immutable. Очень подходит для операции по поиску элементов и мат операциях на множествах.
 13) range - прогрессирующая коллекция.
!!! В Python нету char !!!

enumerate(list) - создает коллекцию пар с индексом и соответствующим значением.

If bool:
    print("true")
else:
    print("false") - if statement.
Есть концепт так называемых Truthy value:
 1) Integer превращается в true если он != 0.
 2) String превращается в true если он != "".
Так же есть версия с if not ... . Можно использовать and or or, являющимися эквивалентами к && and || соотвественно.
Тернарная операция: "bigger" if a > b else "smaller".

For student in students:
    ptint(student) - итерирует по студентам и что-то с ними делает, похож на for-each в java. Это работает только с интерируемыми объектами.
Функция range() принимает число и конвертирует его в список от нуля до числа. Можно использовать как for по числу, как в других ЯП. Но так же можно передать два числа, чтобы специфицировать то, с какого и до какого числа нам нужен лист. И еще есть версия с 3-я аргументами, которые позволяет нам указать на какое число нужно инкрементить. Можно использовать такие statement как brake and continue.

x=0
While x < 10:
    print(x)
    x += 1 - while цикл, такое же как и во всех других языках.

Exceptions:
Они действуют так же как и во всех ЯП и их так же можно перехватывать.
try:
    student["last_name"]
except KeyError as error:
    print("Error was raised")
    print(error)
Можно обрабатывать сразу две ошибки путем объединения их в tuple (someex1, someex2).
Идет подразделение на Exception, это то, что человек может отловить и Program Error, это программные ошибки Python, их надо фиксить.
Exceptions can not be ignored.
С помощью слова rise мы можем руками вызвать поднятие ошибки. Exceptions должны быть хорошо задокументированы и использоваться по возможности уже существующие.
!!! Не нужно защищаться от TypeError(), так как это противоречит тому что python есть и может ограничить ваш функционал!!!
При программировании есть два подхода, 1 - это проверять все условия перед выполнением кода и 2[EAFP] - это бросать исключения при не удачном выполнении.
Конструкции можно использовать для platform specific кода.

Functions:
Функции объявляются по всем правилам Python кода и действуют так же как и во всех ЯП. Кроме того нам разрешено делать аргументы optional. Поддерживается именовать передаваемы аргументы при вызове функции. Для того чтобы функция могла принимать произвольное количество элементов, в сигнатуре надо определить переменную с именем *args, которая будет являться листом. Для того чтобы произвольное количество аргументов могли передаваться в виде именованных аргументов, их надо принимать в сигнатуре функции в виде **kwargs, где kwargs является dictionary и образуется к аргументам по ключу. Функции могут быть nested и nested функции имеют доступ к переменным функции родителя.
Функции это не только какое-то объявление, это statement, который обозначает привязку какого-то кода к имени функции. Дефолтные аргументы должны идти сразу после обязательных аргументов. Дефолтные аргументы вызываются только тогда, когда вызывается def, дальше возвращается только их вычисленное значение.

Generator:
Yield - позволяет нам писать свой итератор в виде функции. Вся суть в том, что это слово возвращает генератор, а не итератор, а разница в том что первый из них позволяет пройтись по коллекции только 1 раз (после каждой итерации забывает про прошедшее значение), а второй сколько угодно раз (хранит все значения в памяти). По факту вызываемая функция не выполняется, а просто возвращает генератор. Код вызывается каждый раз когда выполняется итерация в for, и поскольку код натыкается на слово yield. Генератор считается пустым покуда он не натыкается на yield или не сработает какой-то if statement. Lazy evaluation, позволяет создавать бесконечный коллекции. 
Генератор так же может содержать return без аргументов.
Каждый вызов к генератору создает новый генератор.

Lambda functions - это безымянные функции, которые могут принимать аргумент. double = lambda x: x * a. Применяется в high-order functions.

Class:
 Все так же как и в других ЯП, объявляется по правилам Python. Для создания объекта класса нужно написать Clazz(). Ключевое слово self, в параметрах метода подразумевает ссылку на инстанс класса и должен быть первым параметром. Для того чтобы создать конструктор, мы должны создать метод __init__, где первым параметром обязательно должен быть self, на самом деле называется он не конструктор, а инициализатор, потому, что все, что он делает, это конфигурирует уже готовый объект. def __str__ - аналог toString in Java. Для того чтобы определить instance attributes, нужно в конструкторе написать self.var = ..., это создан нам поле. Можно создавать class attributes путем объявления переменной на уровне класса, которые будут считаться как статические переменные. Присутствует так же наследование, которое выражается тем, что в скобки объявления класса передаётся название класса родителя, и работает наследник так же как и везде. Для того чтобы обратиться к методам и переменным родителя, достаточно будет написать self(). Так как нет ключевых слов обозначающих области видимости, решено было обозначать методы, которые не подлежат использованию или переопределению с ключевого нижнего подчеркивания. Так же нет интерфейсов. Все что не предусмотрено для облова пользователем начинается с _.

Import - можно импортировать все что угодно, от классов до переменных. Импортируется файл.

pass - ключевое слово которое говорит компилятору не делать ничего.

Virtual Environment - это возможность создавать виртуальные среды python, где можно использовать версию питона или пакеты которые нужны тебе.

/ - возвращвет float.
// - возвращает int.

Все специальные атрибуты в Python начинаются с __.
__name__ - возвращает название модуля если был импортирован (выполняется единожды при первом импорте), или выводит __main__, если был вызван как script.

whole shebang - строчка сверху которая характеризует то, какая версия python должна использоваться при запуске.

== (Value) - сравнивает значение двух объектов, в то время как is (Identity) - сравнивает ссылки двух объектов.

Python name scopes:
Local - внутри сейчашней функции.
Enclosing - Any and all enclosing functions.
Global - top-level of module. Обычно явяются модулями, функциями, константами и изредка переменными.
Built-in - provided by builtins module.
Для разрешения ситуаций когда мы хотим использовать глобальную переменную, мы должны объявить ее как global var в функции для того чтобы не создавалось локальная с таким же именем.

Все в питоне объект: от переменных до импортов.

List comprehension:
a = [x**2 for x in range(10)] --> 0, 1, 4, 9 ... .

Set comprehension:
a = {x**2 for x in range(10)}  --> 0, 1, 4, 9 ... .

Dictionary comprehension:
capital_to_country = {capital: country for country, capital in country_to_capital}.

Generator comprehension:
a = (x**2 for x in range(10)) --> 0, 1, 4, 9 ... .
Так же он автоматически вызывается в случаях когда пишется comprehension в функциях.

В comprehension можно включать выражения if: [x for x int range(101) if is prime(x)].

Iterator:
Iterable protocol: Iterable object можует быть передан в встроенную iter() функцию для получения iterator. iterator = iter(iterable)
Iterator Protocol: Iterator object мб передан в встроенную built-in функцию next() для того чтобы получить следующий элемент. item = next(iterator).
For loop потсроен вокруг low level iteration протокола.

Working with files:
 Файл, открытый в формате байта, возвращает и манипулирует с данными как с байт объектами без декодировки. Binary формат отражает raw data в файле. А файл открытый в формате text сразу декодирует binary формат. При чтении Python использует default encoding, но это не факт что на всех системах она будет одинаковая. При окончании работы с ними обязательно их нужно закрывать для того чтобы все данные точно были записаны и не было переполнения памяти, если много файлов открывается на чтение.

With ... as ... позволяет использовать любой объект, который имеет в себе open, take and close методы. 

Tests:
TestCase - сгруппированные вместе связанные тест функции.
Fixtures - сод запускаем до и после каждой тест функции. Используется для того чтобы уверить в том что test environment готово к тому чтобы запускать тесты. Или так же используются для того чтобы отчистить ресурсы после использования test метода.
Assertions - специальные тесты для условий и поведения. (assertEqual, assertRaises).
Pdb - удобный tool для дебага python программы.

Packaging:
Distutils - модуля для того чтобы распространять наши пакеты и код среди других юзеров.

Когда Python импортирует пакеты, он смотрит в локациях, которые есть в sys.path. Они доварятся в таком порядке: директория из которой запускается скрипт, директория в PYTHONPATH environment переменной.
Сам из себя модуль os представляет набор файлов с функционалом внутри.
Чтобы посмотреть где лежит модуль, можно написать print(os.__file__)

Модули:
sys - для работы с интерпретатором, например взять аргументы
os - для работы с системой. Из себя представляет уже реализованные в platform specific пакетах: posix and nt функции, которых реализацию он выбирает в зависимости от того, какая платформа используется (выбор происходит при импорте в первый раз).
random - для работы с рандомными числами
math - для работы с математическими формулами
datetime - для работы с временем
calendar - для работы с датами
shutil - Модуль который имеет полезный функционал для работы с файлами или коллекцией файлов. Например копирование или удаление.
argparse - Позволяет легко строить user-friendly консольные программы.
Logging - Очевидно, для логирования
Subprocess - позволяет запускать non python скрипты, будь то баш команды или программы на других ЯП, например java. Позволяет припконнектиться к input/output/error потокам другой программы. Он 
Data-format-libraries - есть библиотеки для работы с форматами данных. ИЗ коробки идет JSON and cfg/ini.
Unittest - библиотека для юнит тестов.

Shutil:
В большинстве своем используется именно для того чтобы перемещать, копировать или что-то другое файлы или директории.
copy(src, dst) - позволяет копировать файлы из сорса в назначение.
copystat() - то же самое, но с мета инфой.
Есть огромная вариация функций, например для копирования, перемещения и удаления директорий.
Так же можно копировать permission, например все permission с Desktop на какой-нибудь файл.
C этой библиотекой даже можно архивировать файлы.

Sys:
Модуль для работы с интерпретатором.
argv - лист аргументов переданных при запуске файла, первым всегда идет название файла.
executable - возвращает путь до python интерпретатора.
exit - позволяет насильно выйти из python программы.
path - лист путей, которые использует python для поиска модулей.
platform - взять информацию о платформе на которой мы работаем.
stdin / stdout / stderr - используется для ввода, вывода информации или ошибок. По идеи то же самое что и print or input, только low level. Stdin - позволяет принимать данные, которые могут потом быть evaluated.
Так же можно взять информацию о платформе на которой запускаем.

Argparse:
Определяет какие аргументы нужны. Автоматически понимает как парсить аргументы приходящие с argv. Так же имеет возможность конверции string into object. Автоматически генерирует help and issue.
Можно добавить так называемые mutable exclusive group, это когда при запуске программы мы объявляем флаги, которые могут не использоваться вообще или использоваться по одному.

Logging:
Очень удобный инструмент для логгирования. При всем при этом мы можем настроить логгер в 1 месте и переиспользовать его где нам будет удобно путем простого импорта того же логгера. Это будет работать, так как мы уже будем использовать дважды импортированный модуль.
Есть 5 уровней логинга: info, debug, warning, error, critical. По дефолту warning level. 

Subprocess:
Позволяет запускать non python скрипты, будь то баш команды или программы на других ЯП, например java. Позволяет припконнектиться к input/output/error потокам другой программы. Можно использовать функцию call, в которую можно передать в качестве листа команду и ее аргументы. Shell=True при передаче аргументов в call, означает что строку нужно обрабатывать как единую команду, а не вызов одной операции, но такое поведение опасно. Есть еще функция check_output, благодаря которой мы можем вызвать какую-либо команду и получить ответ в виде результата, а не кода ошибки в программу python. При открытии процесса через Popen() мы можем управлять им, получат статус программы, ждать закрытия или что-то еще.

Data-format-libraries:
Json - стандартная библиотека, которая конвертирует string json в dict, и наоборот. Есть разные вариации с load/loads and dump/dumps - которые позволяют читать с и писать в строки/файла соответственно.
Configparser - стандартная библиотека для работы с конфигами. 

Unittest: 
Позволяет нам писать unittest'ы прямо из коробки. Есть в наличие assertEqual() to check for an expected result; assertTrue() or assertFalse() to verify a condition; or assertRaises() to verify that a specific exception gets raised. setUp() and tearDown() позволяют написать функционал, который будет лбо выполняться до либо после соответсвующего теста. unittest.main() запускает тесты. Каждый тест кейс должен быть автономным. Все test методы должны начинаться со слова test. Тесты выполняются в порядке который определяется порядком стрингов. 
Так же есть поддержка скипингов тестов или даже целых классов тестов. Так же можно пометить тест как “expected failure” и он не будет дрожать другие тесты из-за того что он упал. Для того чтобы скипнуть нужно использовать skip(), skipIf() or skipUnless декоратор. 
В setUp() так же можно скупать тесты. Есть декортов для expectedFailure.  
Методы setUpClass() and tearDownClass() - статические методы, с помощью которых м делаем установки перед или после запуска всех классов в пределе одного класса.
Так же Сожно тестировать с замоканными данными с помощью patch элемента из unittest.mock. Path может быть использован как context manager, где в его парламенты мы передаем объект который хотим заменить и устанавливаем его параметры.

First-class functions:
Python саппортит концепт first class functions: Являются объектами класса Object, можно хранить функции в variable, можно передавать функции в параметры другим функциям, можно вернуть функции из других функций, можно хранить функции в структурах.

Closures:
Ключевое слово nonlocal обозначает то, что внутренняя функция должна взять переменную из enclosing function. Само по себе closures обозначает то, что внутренняя функция будет помнить переменные, которые были вне ее, даже после того как эту саму внутреннюю функцию вернули, а внешняя закончила свое исполнение.

Decorators:
Те же самые аннотации из мира Java, позволяют окутать функцию неким функционалом. Для этого декоратор должен быть объявлен как функция и при этом принимать функцию в качестве параметра и возвращать внутреннюю функцию, а внутренняя функция уже делает с переданной функцией что хочет. 
Так же можно создавать декораторы из классов, где мы кладем функцию которую хотим декорировать в __init__. Так же для того чтобы имитировать inner function нужно определить функцию __call__, которая возвращает результат переданной в конструктор функции. 
Wraps декоратор из functools модуля позволяет нам навешивать этот декоратор на существующие декораторы для того чтобы избежать коллизии декораторов, в этот декоратор нам надо передавать функцию которую декорируем.

Everything is an Object. Mutable vs Immutable:
Все immutable объекты имеют одно и то же место в памяти, пример:
а = "авс"
в = "авс"
a is b == true.
Все mutable объекты имеют разные участки в памяти, пример:
а = [1,2,3]
в = [1,2,3]
a is b == true.
Таким образом мы имеем биндинг многих имен на одни и те же объекты.
Python оптимизирует использование памяти, то есть если объект с таким же значением уже присутствует в памяти, то ссылка на переменную ссылается на тот же участок памяти с тем же объектом. Обычно нам не нужно переживать за то какое количество памяти выдается Python в рамках компьютера, и эта память делится на Stack memory and heap memory. В стеке у нас хранятся области с методами и с ссылками на объекты, которые хранятся в heap. Интересен механизм перезаписи, так как каждая функция формирует свой фрейм, то перезаписи каких-либо переменных не приводят ни к каким эффектам тех же переменных в других функциях. Объекты создаются в heap, с ссылками на свои внутренние переменные. 
Тут так же есть GC. Алгоритм использующий GC называется Reference Counting. Его преимущество в том что он очищает память сразу когда объект переспеет быть ссылаемым, так же минус в том что вызывается каждый раз.
Можно создать ссылки которые не будут считаться от GC (weakref).
В то время как в Java - 10 - является примитивным типом который хранятся в стеке. В Python  - 10 - является объектом. При изменение переменных, в Python создается новая область с новым значением, в Java у нас не создается новая область, лишь изменяется предыдущая. При создании переменных с одним и тем же значением, в python, создается две переменные с мылкой на один и тот же участок памяти, а в джава создается две разные области в стеке.

Boolean is an Integer:
В Python booleans являются подтипами Integer.

What does the '__main__' mean: 
Каждый модуль имеет специальный атрибут называемый __name__, и имя __name__ будет == '__main__' в случае когда модуль запускается как программа, а иначе будет нести имя модуля.

Parallel computation:
Thread(*name of function*) - создает поток.
thread.start() - запускает этот поток
thread.join() - вызывающий поток ждет окончания потока на котором вызывается этот метод.

ThreadPoolExecutor:
Можем использовать в конструкции with... .
И затем вызывать на executor.submit(*func name*, ...*func parameters*...). Вызывает функцию в параллельном потоке, thread.result() - возвращает результат, поток будет ждать до тех пор, пока не будет возвращен результат.
executor.map(do_smth, *params list*) - позволяет запустить выполнение функции с количеством переданных параметров, главное то, что результат будет возвращаться в том же порядке.

Разница между MultiTreading and Multiprocessing, в том, что в первом случае орнитологий заменяют друг друга, а в другом они работают параллельно. Почти все конструкции, которые есть в первом, существуют и на втором.

Python Underscores:
Всего 5 случаев когда _ применим:
 1. Хранения значений последних выражений в интерпретаторе.
  >>> 10 
  10 
  >>> _ 
  10
 2. Для игнорирования специальных значений.
  x, _, y = (1, 2, 3) # x = 1, y = 3 
 3. To give special meanings and functions to name of vartiables or functions.
  Single underscore для того чтобы обозначить приватные поля и методы.
  Single trailing underscore для того чтобы избежать конфликта наших имен с зарезервированными от python.
  Double leading underscore такие переменные и функции воспринимаются компилятором с именем, таким же, но с добавлением _ClassName.
  Double leading and trolling underscores используются для того, чтобы обозначит так называемые “magic method”. В их список входят: __init__, __eq__, __file__ and another.
 4. To use as ‘Internationalization(i18n)’ or ‘Localization(l10n)’ functions.
 5. To separate the digits of number literal value.
  dec_base = 1_000_000.

Magic methods:
Before creating the instance of the class “__new__” method will be called. This method takes parameter “class”, “args”, “kwargs” and It will bind the data type to given class. После этого он вызовет "__init__" метод.
Вообще магических методов очень много.

Flask: 
 Из коробки мы имеем возможность принимать GET запросы:
 @app.route('/books')
  def() ... .
 Но из коробки не так много возможностей, так что возможно прийдется докачиввть какие-то пакеты. Вообще основным плюсом считается то что нет огромного количества не нужных библиотек, все остальное нужное нужно докачивать. Так же у нас есть плюс в его не вербозности.
 Если мы хотим принять какой-то параметр в наш обработчик, то следует написать так:
 @app.route('/books/<int:isbn>')
  def(isbn) ... .
 Для того чтобы сделать POST Request обработчик, нужно написать:
 @app.route('/books', methods=[POST])
 У request у Flask есть метод get_json.

Scrapy: 
 Инструмент, позволяющий нам исследовать сайты, и брать какую-либо важную информацию. Данные приходят в структурированной форме. Вместе с тулой приходит cli, который позволяет быстро проследовать взятие данных. Селекторы позволяют определить CSS или XPATH для взятия информации. 
Разница между Web Scraping and Web Carwling в том, что первый для того чтобы брать инфу непосредственно с сайта(цены на разные вещи), а второй для того чтобы серчить сайты полностью.











